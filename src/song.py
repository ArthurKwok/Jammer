#Last modified: 25 Sep, 2020
#Author: Arthur Jinyue Guo jg5505@nyu.edu

import os
# import numpy as np
# import music21
import attr
import json

@attr.s(kw_only=True)
class Song(object):
    """Settings of a song accompaniment. Contains methods to generate .mma file and midi file.

    @pattern_progression: list of ints of length 3, where to swtich grooves. 
                          pattern_progression[0] is the starting bar of Main1, 1 for Main2, and 3 for Outro. 
                          Bar count starts at 1, not 0.
    """
    name = attr.ib(type=str, default="untitled")
    genre = attr.ib(type=str)
    tempo = attr.ib(type=int)
    chord_progression = attr.ib(type=str)
    pattern_progression = attr.ib(type=list)
    style_path = attr.ib(type=str, default="./style.json")


    #
    # init functions 
    #
    @tempo.validator
    def check_tempo(self, attribute, value):
        if value < 40 or value > 250:
            raise ValueError(f"Invalid tempo value: {tempo}")

    @pattern_progression.validator
    def check_pp(self, attribute, value):
        if len(value) != 3:
            raise ValueError(f"Invalid pattern progression length: {len(value)}")
        if value[0] < 0 or value[1] < 0 or value[2] < 0 or \
           value[1] < value[0] or value[2] < value[1] or value[2] < value[0]:
           raise ValueError(f"Invalid pattern progression value: {value}")
        if value[0] > len(self.chord_progression.split("\n"))-1 or \
           value[1] > len(self.chord_progression.split("\n"))-1 or \
           value[2] > len(self.chord_progression.split("\n"))-1:
           raise ValueError(f"Invalid pattern progression, must be smaller than chord progression : {value}")

    def __attrs_post_init__(self):
        self.genre = self.genre.lower()
        # load style config file
        with open("./styles.json", "r") as f:
            f_json = json.load(f)
            self.supported_styles = f_json["supported_styles"]
            self.styles = f_json["styles"]

        if self.genre not in self.supported_styles:
            raise ValueError(f"Unsupported song style: {value}")

        self.groove = self.styles[self.genre]


    #
    # class methods
    #
    def build_mma(self, mma_path, verbose=False)->str:
        """build mma file from Song class

        return: path of generated .mma file
        """
        if os.path.exists(mma_path) and verbose:
            print("File already exists: {}, overwriting.".format(mma_path))

        mma_string = ""
        # mma_string += "Debug Debug=1 Runtime=1"
        mma_string += f"Tempo {self.tempo}\n"
        mma_string += "\nGroove {}\n\n".format(self.groove["Intro"])

        for bar_index, chord in enumerate(self.chord_progression.split("\n")[:-1]):
            if self.pattern_progression[0] == bar_index + 1:
                mma_string += "\nGroove {}\n\n".format(self.groove["Main1"])
            elif self.pattern_progression[1] == bar_index + 2:
                mma_string += "\nGroove {}\n\n".format(self.groove["Fill"])
            elif self.pattern_progression[1] == bar_index + 1:
                mma_string += "\nGroove {}\n\n".format(self.groove["Main2"])
            elif self.pattern_progression[2] == bar_index + 1:
                mma_string += "\nGroove {}\n\n".format(self.groove["Outro"])
            
            mma_string += f"{bar_index+1}\t{chord}\n"

        mma_string += "\nz\nz!"

        with open(mma_path, "w") as file:
            # header comments
            file.write("// This file is automatically generated by Song class.\n")
            file.write("// {}\n\n".format(self.name))

            # song information
            file.write(mma_string)
        
        if verbose:
            print(f"mma file written and saved: {mma_path}")

        return mma_path


    def build_midi(self, mma_path, verbose=False)->str:
        """build midi file from a existing mma file

        return: path of generated .midi file
        """
        stream = os.popen(f"mma {mma_path}")
        output = stream.read()
        if verbose:
            print(output)
        if ("command not found" in output or "mma: not found" in output):
            raise SystemError("MMA not installed.")
            return None
        if ("not found" in output):
            raise SystemError(f".mma file not found: {mma_path}")
            return None       
        file_name = output.split(":")[-1].split("/")[-1][:-2]

        return os.path.join(os.path.split(mma_path)[0], file_name)


    def build(self, mma_path, clear_temp=True, verbose=False)->str:
        """directly build midi file from Song class

        return: path of generated .mma(if clear_temp==False) & .midi file
        """
        self.build_mma(mma_path, verbose=verbose)
        midi_path = self.build_midi(mma_path, verbose=verbose)

        if clear_temp:
            os.remove(mma_path)
            if verbose:
                print(f"Removed file: {mma_path}")

        return midi_path        




if __name__ == "__main__":
    my_song = Song(name="my song",
                    genre="pop",
                    tempo=110,
                    chord_progression="D\nBm\nG\nA7\nD\nBm\nG\nA7\nD\nBm\nG\nA7\nD\nBm\nG\nA7\n",
                    # chord_progression="Dm7\nG7\nCM7\nCM7\nDm7\nG7\nCM7\nCM7\nDm7\nG7\nCM7\nCM7\nDm7\nG7\nCM7\nCM7\n",
                    pattern_progression=[5, 8, 15])

    # print(my_song.build_midi("/home/jovyan/workspace/MMA-playground/fella1.mma"))

    my_song.build("../output.mma", clear_temp=False, verbose=True)
    # my_song.render_audio(soundfont_path=None, midi_path="../output.mid", audio_path="../output_pop.wav", verbose=True)
    Producer.render_audio(soundfont_path="../downloads/Orpheus_18.06.2020.sf2", midi_path="../output.mid", audio_path="../output_pop.wav", verbose=True)