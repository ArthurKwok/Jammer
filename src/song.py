import os
import numpy as np
# import music21
import attr
from typing import Tuple

@attr.s(kw_only=True)
class Song(object):
    """Settings of a song accompaniment. Contains methods to generate .mma file and midi file.

    @pattern_progression: list of ints of length 3, where to swtich grooves. 
                          pattern_progression[0] is the starting bar of Main1, 1 for Main2, and 3 for Outro. 
                          Bar count starts at 1, not 0.
    """
    name = attr.ib(type=str, default="untitled")
    style = attr.ib(type=str)
    tempo = attr.ib(type=int)
    chord_progression = attr.ib(type=str)
    pattern_progression = attr.ib(type=list)

    supported_styles = ["Pop",
                        "Rock",
                        "Jazz",
                        "Folk"]

    #TODO: assign style-related instrument and groove
    #TODO: add song structure(intro, outro, repeat, ...)

    groove = attr.ib(type=str, init=False)

    @style.validator
    def check_style(self, attribute, value):
        if value not in self.supported_styles:
            raise ValueError(f"Unsupported song style: {value}")
    
    @tempo.validator
    def check_tempo(self, attribute, value):
        if value < 40 or value > 250:
            raise ValueError(f"Invalid tempo value: {tempo}")

    @pattern_progression.validator
    def check_pp(self, attribute, value):
        if len(value) != 3:
            raise ValueError(f"Invalid pattern progression length: {len(value)}")
        if value[0] < 0 or value[1] < 0 or value[2] < 0 or \
           value[1] < value[0] or value[2] < value[1] or value[2] < value[0]:
           raise ValueError(f"Invalid pattern progression value: {value}")
        if value[0] > len(self.chord_progression.split("\n"))-1 or \
           value[1] > len(self.chord_progression.split("\n"))-1 or \
           value[2] > len(self.chord_progression.split("\n"))-1:
           raise ValueError(f"Invalid pattern progression, must be smaller than chord progression : {value}")
    
    def build_mma(self, mma_path, verbose=False)->str:
        """build mma file from Song class

        return: path of generated .mma file
        """
        if os.path.exists(mma_path) and verbose:
            print("File already exists: {}, overwriting.".format(mma_path))

        # Choose Groove
        groove = {"Intro": None, "Main1": None, "Main2": None, "Outro": None}
        
        if self.style is "Pop":
            groove["Intro"] = "PopBalladIntro"
            groove["Main1"] = "PopBallad"
            groove["Main2"] = "PopBallad2Plus"
            groove["Outro"] = "PopBalladEnd"
        if self.style is "Rock":
            groove["Intro"] = "Rock1A"
            groove["Main1"] = "50s_RockA"
            groove["Main2"] = "50s_RockB"
            groove["Outro"] = "50s_RockEndingC"
        if self.style is "Jazz":
            groove["Intro"] = "SlowJazzIntro"
            groove["Main1"] = "SlowJazz"
            groove["Main2"] = "SlowJazzSus"
            groove["Outro"] = "SlowJazzEnd"
        if self.style is "Folk":
            groove["Intro"] = "FolkRockIntro"
            groove["Main1"] = "FolkRock"
            groove["Main2"] = "FolkRockSusPlus"
            groove["Outro"] = "FolkRockEnd"

        mma_string = ""
        mma_string += f"Tempo {self.tempo}\n"
        mma_string += "\nGroove {}\n\n".format(groove["Intro"])

        for bar_index, chord in enumerate(self.chord_progression.split("\n")[:-1]):
            if self.pattern_progression[0] == bar_index + 1:
                mma_string += "\nGroove {}\n\n".format(groove["Main1"])
            elif self.pattern_progression[1] == bar_index + 1:
                mma_string += "\nGroove {}\n\n".format(groove["Main2"])
            elif self.pattern_progression[2] == bar_index + 1:
                mma_string += "\nGroove {}\n\n".format(groove["Outro"])
            
            mma_string += f"{bar_index+1}\t{chord}\n"

        mma_string += "\nz\nz!"

        with open(mma_path, "w") as file:
            # header comments
            file.write("// This file is automatically generated by Song class.\n")
            file.write("// {}\n\n".format(self.name))

            # song information
            file.write(mma_string)
        
        if verbose:
            print(f"mma file written and saved: {mma_path}")

        return mma_path


    def build_midi(self, mma_path, verbose=False)->str:
        """build midi file from a existing mma file

        return: path of generated .midi file
        """
        stream = os.popen(f"mma {mma_path}")
        output = stream.read()
        if verbose:
            print(output)
        if ("command not found" in output or "mma: not found" in output):
            raise SystemError("MMA not installed.")
            return None
        if ("not found" in output):
            raise SystemError(f".mma file not found: {mma_path}")
            return None       
        file_name = output.split(":")[-1].split("/")[-1][:-2]

        return os.path.join(os.path.split(mma_path)[0], file_name)


    def build(self, mma_path, clear_temp=True, verbose=False)->str:
        """directly build midi file from Song class

        return: path of generated .mma(if clear_temp==False) & .midi file
        """
        self.build_mma(mma_path, verbose=verbose)
        midi_path = self.build_midi(mma_path, verbose=verbose)

        if clear_temp:
            os.remove(mma_path)
            if verbose:
                print(f"Removed file: {mma_path}")

        return midi_path        


    def render_audio(self, soundfont_path, midi_path, audio_path, verbose=True):
        if soundfont_path is None:
            soundfont_path = "../downloads/FluidR3Mono_GM.sf3"
        stream = os.popen(f"fluidsynth {soundfont_path} {midi_path} -F {audio_path}")
        output = stream.read()
        if verbose:
            print(output)


if __name__ == "__main__":
    my_song = Song(name="my song",
                    style="Folk",
                    tempo=100,
                    chord_progression="Dm7\nG7\nCM7\nCM7\nDm7\nG7\nCM7\nCM7\nDm7\nG7\nCM7\nCM7\nDm7\nG7\nCM7\nCM7\n",
                    pattern_progression=[3, 8, 15])

    # print(my_song.build_midi("/home/jovyan/workspace/MMA-playground/fella1.mma"))

    my_song.build("../output.mma", clear_temp=False, verbose=True)
    my_song.render_audio(soundfont_path=None, midi_path="../output.mid", audio_path="../output.wav", verbose=True)